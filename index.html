<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mines & Bombs â€” Realistic Minesweeper</title>
<style>
  :root{--bg:#0b1220;--panel:#0f1724;--accent:#ffcc33;--danger:#ff5b5b;--muted:#9aa3b2}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#071226,#0b1220);color:#e6eef8}
  .app{max-width:980px;margin:28px auto;padding:18px;border-radius:12px}
  header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
  h1{font-size:20px;margin:0}
  .controls{display:flex;gap:8px;align-items:center}
  select,button{padding:8px 10px;border-radius:8px;border:0;background:linear-gradient(90deg,#1b2633,#111827);color:#e6eef8;cursor:pointer}
  button.primary{background:linear-gradient(90deg,var(--accent),#f09d2e);color:#071226}
  .board-wrap{display:flex;gap:16px}
  .left{flex:1}
  .info{width:260px;background:rgba(255,255,255,0.02);padding:12px;border-radius:10px}
  .hud{display:flex;gap:8px;margin-bottom:8px}
  .hud .panel{background:rgba(0,0,0,0.25);padding:8px;border-radius:8px;min-width:72px;text-align:center}
  .grid{display:grid;gap:4px;background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:8px;border-radius:8px}
  .cell{width:36px;height:36px;border-radius:6px;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#1b2633,#111827);cursor:pointer;user-select:none;box-shadow:inset 0 -2px 0 rgba(0,0,0,0.4);font-weight:700}
  .cell.revealed{background:linear-gradient(180deg,#cbd5e1,#e6eef8);color:#071226;box-shadow:none;cursor:default}
  .cell.flagged{background:linear-gradient(180deg,#2b2f3a,#1b2026);}
  .cell.mine{background:linear-gradient(180deg,#2b2a2a,#3a2a2a)}
  .footer{margin-top:12px;color:var(--muted);font-size:13px}
  .big{font-size:24px}
  .small{font-size:13px;color:var(--muted)}
  canvas.explosion{position:absolute;left:0;top:0;pointer-events:none}
  /* responsive */
  @media (max-width:880px){.info{display:none}.cell{width:30px;height:30px}}
</style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Mines & Bombs â€” Realistic Minesweeper</h1>
      <div class="controls">
        <label class="small">Difficulty:</label>
        <select id="difficulty">
          <option value="easy">Easy (9Ã—9, 10 mines)</option>
          <option value="medium">Medium (16Ã—16, 40 mines)</option>
          <option value="hard">Hard (30Ã—16, 99 mines)</option>
        </select>
        <button id="newBtn" class="primary">New Game</button>
        <button id="hintBtn">Reveal Safe</button>
      </div>
    </header>

    <div class="board-wrap" style="position:relative">
      <div class="left">
        <div class="hud">
          <div class="panel"><div class="small">Mines</div><div id="mineCount" class="big">0</div></div>
          <div class="panel"><div class="small">Time</div><div id="timer" class="big">0</div></div>
          <div class="panel"><div class="small">Flags</div><div id="flagCount" class="big">0</div></div>
        </div>

        <div id="gridWrap" style="position:relative">
          <div id="grid" class="grid" role="grid" aria-label="Mines grid"></div>
          <canvas id="explosion" class="explosion"></canvas>
        </div>
      </div>

      <aside class="info">
        <div style="margin-bottom:8px"><strong>How to play</strong>
          <p class="small">Left-click to reveal a tile. Right-click to place a flag. Numbers show adjacent mines. Reveal all non-mine tiles to win. If you click a mine â€” boom.</p></div>
        <div style="margin-bottom:8px"><strong>Realistic features</strong>
          <ul class="small" style="margin:6px 0 0 18px;padding:0">
            <li>Explosion particles & screen shake on detonation</li>
            <li>Subtle tile animations and sound using WebAudio</li>
            <li>Auto-safe reveal and smart chording</li>
          </ul>
        </div>
        <div style="margin-top:12px"><strong>Stats</strong>
          <p class="small">Best times saved per difficulty in localStorage.</p>
          <div id="bestTimes" class="small"></div>
        </div>
      </aside>
    </div>

    <div class="footer">Tip: on mobile, long-press to flag. Use the "Reveal Safe" button for a hint (costs small time penalty).</div>
  </div>

<script>
// Mines & Bombs â€” Minesweeper with realistic explosions
// Single-file implementation, no external assets. Uses WebAudio for sound.
(() => {
  // DOM
  const gridEl = document.getElementById('grid');
  const gridWrap = document.getElementById('gridWrap');
  const explosionCanvas = document.getElementById('explosion');
  const mineCountEl = document.getElementById('mineCount');
  const flagCountEl = document.getElementById('flagCount');
  const timerEl = document.getElementById('timer');
  const difficultySel = document.getElementById('difficulty');
  const newBtn = document.getElementById('newBtn');
  const hintBtn = document.getElementById('hintBtn');
  const bestTimesEl = document.getElementById('bestTimes');

  // Audio setup (simple oscillator/samples created on the fly)
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audioCtx = AudioCtx ? new AudioCtx() : null;
  function playBeep(freq, time=0.06, type='sine'){
    if(!audioCtx) return; const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type = type; o.frequency.value = freq; g.gain.value = 0.08; o.connect(g); g.connect(audioCtx.destination); o.start(); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + time); o.stop(audioCtx.currentTime + time + 0.02);
  }
  function playExplosion(){ if(!audioCtx) return; const o1=audioCtx.createOscillator(); const o2=audioCtx.createOscillator(); const g=audioCtx.createGain(); o1.type='sawtooth'; o2.type='square'; o1.frequency.value=120; o2.frequency.value=40; g.gain.value=0.2; o1.connect(g); o2.connect(g); g.connect(audioCtx.destination); o1.start(); o2.start(); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + 0.8); o1.stop(audioCtx.currentTime + 0.8); o2.stop(audioCtx.currentTime + 0.8); }

  // Game settings by difficulty
  const DIFF = {
    easy: {cols:9, rows:9, mines:10},
    medium: {cols:16, rows:16, mines:40},
    hard: {cols:30, rows:16, mines:99}
  };

  // State
  let cols=9, rows=9, mines=10;
  let cells = []; // {mine, revealed, flagged, adj}
  let started = false; let timer=0; let timerID=null;
  let flags = 0; let remaining = 0; // non-mine remaining
  let bestTimes = JSON.parse(localStorage.getItem('mb_best')||'{}');

  // explosion canvas setup
  const exCtx = explosionCanvas.getContext('2d');
  function resizeCanvas(){ explosionCanvas.width = gridWrap.clientWidth; explosionCanvas.height = gridWrap.clientHeight; }
  window.addEventListener('resize', resizeCanvas);

  // helpers
  function idx(x,y){ return y*cols + x; }
  function inBounds(x,y){ return x>=0 && y>=0 && x<cols && y<rows; }

  function setDifficulty(key){ const d = DIFF[key]; cols=d.cols; rows=d.rows; mines=d.mines; }

  function buildGrid(){ gridEl.innerHTML=''; gridEl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`; gridEl.style.gridTemplateRows = `repeat(${rows}, 1fr)`; cells = new Array(cols*rows).fill(null).map(()=>({mine:false,revealed:false,flagged:false,adj:0,el:null}));
    for(let y=0;y<rows;y++){ for(let x=0;x<cols;x++){ const cell = cells[idx(x,y)]; const div = document.createElement('div'); div.className='cell'; div.dataset.x=x; div.dataset.y=y; div.setAttribute('role','button'); div.setAttribute('aria-label','Unrevealed'); gridEl.appendChild(div); cell.el = div; bindCellEvents(div); }}
    resizeCanvas(); updateHUD(); }

  function placeMines(firstX, firstY){ // ensure first click safe (no mine on first or neighbors)
    let available = [];
    for(let y=0;y<rows;y++) for(let x=0;x<cols;x++){ // exclude first and neighbors
      const dx = Math.abs(x-firstX), dy = Math.abs(y-firstY);
      if(Math.max(dx,dy) <= 1) continue; available.push({x,y}); }
    // shuffle
    for(let i=available.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [available[i],available[j]]=[available[j],available[i]]; }
    for(let i=0;i<mines;i++){ const p=available[i]; cells[idx(p.x,p.y)].mine=true; }
    // compute adjacents
    for(let y=0;y<rows;y++) for(let x=0;x<cols;x++){ let c=0; for(let oy=-1;oy<=1;oy++) for(let ox=-1;ox<=1;ox++){ if(ox===0&&oy===0) continue; const nx=x+ox, ny=y+oy; if(inBounds(nx,ny) && cells[idx(nx,ny)].mine) c++; } cells[idx(x,y)].adj=c; }
  }

  function revealCell(x,y){ if(!inBounds(x,y)) return; const c = cells[idx(x,y)]; if(c.revealed || c.flagged) return; c.revealed=true; c.el.classList.add('revealed'); c.el.setAttribute('aria-label','Revealed'); if(c.mine){ // BOOM
      c.el.classList.add('mine'); c.el.textContent='ðŸ’£'; triggerExplosion(c.el, x, y); revealAllMines(); lose(); return; }
    // reveal number or empty
    if(c.adj>0){ c.el.textContent = c.adj; c.el.style.color = numberColor(c.adj); }
    else { // flood fill
      for(let oy=-1;oy<=1;oy++) for(let ox=-1;ox<=1;ox++){ if(ox===0 && oy===0) continue; revealCell(x+ox,y+oy); }
    }
    remaining--; checkWin(); }

  function numberColor(n){ const colors = ['#000','#2b6bff','#2b8a44','#d97706','#b91c1c','#6b21a8','#0ea5a0','#374151','#64748b']; return colors[Math.min(n,colors.length-1)]; }

  function revealAllMines(){ for(let i=0;i<cells.length;i++){ const c=cells[i]; if(c.mine && !c.revealed){ c.revealed=true; c.el.classList.add('revealed','mine'); c.el.textContent='ðŸ’£'; } } }

  function toggleFlag(x,y){ if(!inBounds(x,y)) return; const c=cells[idx(x,y)]; if(c.revealed) return; c.flagged = !c.flagged; if(c.flagged){ c.el.classList.add('flagged'); c.el.textContent='ðŸš©'; flags++; } else { c.el.classList.remove('flagged'); c.el.textContent=''; flags--; } updateHUD(); }

  function chord(x,y){ // if number revealed and flags around equals number, reveal neighbors
    const c = cells[idx(x,y)]; if(!c.revealed || c.adj===0) return; let f=0; for(let oy=-1;oy<=1;oy++) for(let ox=-1;ox<=1;ox++){ const nx=x+ox, ny=y+oy; if(inBounds(nx,ny) && cells[idx(nx,ny)].flagged) f++; }
    if(f===c.adj){ for(let oy=-1;oy<=1;oy++) for(let ox=-1;ox<=1;ox++){ const nx=x+ox, ny=y+oy; if(inBounds(nx,ny) && !cells[idx(nx,ny)].flagged) revealCell(nx,ny); } }
  }

  function revealSafeHint(){ // reveal a safe random unrevealed non-mine tile
    let pool = []; for(let i=0;i<cells.length;i++){ const c=cells[i]; if(!c.revealed && !c.mine && !c.flagged) pool.push(i); }
    if(pool.length===0) return; const id = pool[Math.floor(Math.random()*pool.length)]; const x = id%cols, y = Math.floor(id/cols); revealCell(x,y); // small time penalty
    timer += 5; updateTimer(); playBeep(650,0.08,'triangle'); }

  function checkWin(){ if(remaining===0){ // win
      running=false; stopTimer(); playVictory(); showMessage('You Win! Time: '+timer+'s'); saveBestTime(); } }

  function lose(){ running=false; stopTimer(); playExplosion(); screenShake(); showMessage('You hit a mine â€” Boom!'); }

  // Game loop and timer
  let running=false; function startTimer(){ if(timerID) return; timerID = setInterval(()=>{ if(running){ timer++; updateTimer(); } }, 1000); }
  function stopTimer(){ if(timerID){ clearInterval(timerID); timerID=null; } }
  function updateTimer(){ timerEl.textContent = timer; }

  function updateHUD(){ mineCountEl.textContent = mines; flagCountEl.textContent = flags; }

  // messages
  function showMessage(msg){ setTimeout(()=>{ alert(msg); }, 60); }

  function playVictory(){ if(!audioCtx) return; const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.frequency.value=880; o.type='sine'; g.gain.value=0.05; o.connect(g); g.connect(audioCtx.destination); o.start(); o.frequency.exponentialRampToValueAtTime(1320, audioCtx.currentTime+0.4); g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime+0.5); o.stop(audioCtx.currentTime+0.6); }

  // particles & shake
  const particles = [];
  let shake = {x:0,y:0,duration:0};
  function triggerExplosion(cellEl, cx, cy){ // compute pixel position
    const rect = gridWrap.getBoundingClientRect(); const cellRect = cellEl.getBoundingClientRect(); const x = cellRect.left - rect.left + cellRect.width/2; const y = cellRect.top - rect.top + cellRect.height/2; // spawn particles
    for(let i=0;i<30;i++){ particles.push({x,y,vx:(Math.random()-0.5)*6, vy:(Math.random()-0.7)*6, life:Math.random()*1+0.6, r:Math.random()*3+1, col:`hsl(${Math.random()*40},80%,50%)`}); }
    shake.duration = 600; // ms
    playExplosion();
    animateParticles();
  }

  function animateParticles(){ if(!particles.length) return; const now = performance.now(); let last = now; function step(t){ const dt = (t - last)/1000; last = t; exCtx.clearRect(0,0,explosionCanvas.width, explosionCanvas.height); for(let i=particles.length-1;i>=0;i--){ const p = particles[i]; p.life -= dt; if(p.life<=0){ particles.splice(i,1); continue; } p.x += p.vx; p.y += p.vy; p.vy += 9.8*dt; exCtx.beginPath(); exCtx.fillStyle = p.col; exCtx.globalAlpha = Math.max(0, p.life/1.2); exCtx.arc(p.x, p.y, p.r, 0, Math.PI*2); exCtx.fill(); }
      // shake easing
      if(shake.duration>0){ shake.duration -= Math.round(dt*1000); const s = Math.min(12, shake.duration/50); gridWrap.style.transform = `translate(${(Math.random()-0.5)*s}px, ${(Math.random()-0.5)*s}px)`; } else { gridWrap.style.transform = ''; }
      if(particles.length) requestAnimationFrame(step); else exCtx.clearRect(0,0,explosionCanvas.width, explosionCanvas.height);
    }
    requestAnimationFrame(step);
  }

  // reveal all for debug (not used normally)
  function revealAll(){ for(let x=0;x<cols;x++) for(let y=0;y<rows;y++) revealCell(x,y); }

  // event binding for each cell
  function bindCellEvents(div){ let longPressTimer=0; let pressed=false;
    const x = () => parseInt(div.dataset.x,10); const y = () => parseInt(div.dataset.y,10);
    div.addEventListener('contextmenu', e=>{ e.preventDefault(); toggleFlag(x(),y()); });
    div.addEventListener('mousedown', e=>{ if(e.button===2) return; pressed=true; });
    div.addEventListener('mouseup', e=>{ if(e.button===2) return; if(!pressed) return; pressed=false; // left click behavior
      if(!started){ // start game on first click, place mines excluding neighbors
        placeMines(x(),y()); started=true; running=true; startTimer(); }
      if(e.shiftKey || e.altKey){ chord(x(),y()); playBeep(440,0.05); }
      else revealCell(x(),y()); playBeep(600,0.04); });

    // touch support: long-press to flag
    div.addEventListener('touchstart', e=>{ e.preventDefault(); longPressTimer = setTimeout(()=>{ toggleFlag(x(),y()); longPressTimer=0; }, 500); });
    div.addEventListener('touchend', e=>{ if(longPressTimer){ clearTimeout(longPressTimer); longPressTimer=0; // treat as tap
        if(!started){ placeMines(x(),y()); started=true; running=true; startTimer(); }
        revealCell(x(),y()); playBeep(600,0.04);
      } });
  }

  // best time storage
  function saveBestTime(){ const key = difficultySel.value; if(!bestTimes[key] || timer < bestTimes[key]){ bestTimes[key] = timer; localStorage.setItem('mb_best', JSON.stringify(bestTimes)); renderBestTimes(); } }
  function renderBestTimes(){ bestTimesEl.innerHTML = Object.keys
